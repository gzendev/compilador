package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.model.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

class Parser;

parser code
{:
	//SymbolTableStruct currentSymbol;
	//public List<SymbolTableStruct> symbolList = new ArrayList();
	public List<Terceto> tercetos = new ArrayList<>();
	public List<SymbolTableEntry> symbolTable = new ArrayList<>();
	private int terceto_count = 1;
	private Stack<Integer> pila_tercetos = new Stack<>();
	private Stack<String> pila_ids = new Stack<>();
	private Stack<String> pila_tipos = new Stack<>();
	private String currentType;
	
	private int newTerceto(String op, String op1, String op2) {
		Terceto t = new Terceto(op, op1, op2, terceto_count);
		tercetos.add(t);
		return terceto_count++;
	}
	
	private String referenceTerceto(int num) {
		return "[" + num + "]";
	}
	
	private void apilar(int num) {
		pila_tercetos.push(num);
	}
	
	private int desapilar() {
		return pila_tercetos.pop();
	}

	private void addSymbol(String name, String type, String value, int length) throws Exception {
		SymbolTableEntry entry = new SymbolTableEntry(name, type, value, length);
		if (symbolTable.contains(entry)) {
			throw new Exception("Variable ya declarada: " + name);
		}
		symbolTable.add(entry);
	}

	private String getType(String name) {
		for (SymbolTableEntry entry : symbolTable) {
			if (entry.getNombre().equals(name)) {
				return entry.getTipoDato();
			}
		}
		return null;
	}

	private void checkTypes(String type1, String type2) throws Exception {
		if (!type1.equals(type2)) {
			throw new Exception("Error de tipos: no se puede asignar " + type2 + " a " + type1);
		}
	}

	private String getExpressionType(int tercetoNum) {
		Terceto t = tercetos.get(tercetoNum - 1);
		String op = t.getOperador();
		
		switch(op) {
			case "+":
			case "-":
			case "*":
			case "/":
				String type1 = getOperandType(t.getOperando1());
				String type2 = getOperandType(t.getOperando2());
				if (type1.equals("Float") || type2.equals("Float")) {
					return "Float";
				}
				return "Int";
			case "id":
				return getType(t.getOperando1());
			case "cte":
				if (t.getOperando1().contains(".")) {
					return "Float";
				} else if (t.getOperando1().startsWith("\"")) {
					return "String";
				}
				return "Int";
			default:
				return "Unknown";
		}
	}

	private String getOperandType(String operand) {
		if (operand.startsWith("[")) {
			int num = Integer.parseInt(operand.substring(1, operand.length()-1));
			return getExpressionType(num);
		}
		return getType(operand);
	}

	private boolean areTypesCompatible(String type1, String type2) {
		if (type1.equals(type2)) return true;
		if ((type1.equals("Int") && type2.equals("Float")) ||
			(type1.equals("Float") && type2.equals("Int"))) return true;
		return false;
	}

	private void validateIdentifierLength(String id) throws Exception {
		if (id.length() > 50) {
			throw new Exception("Identificador demasiado largo: " + id);
		}
	}

	private void pushType(String type) {
		pila_tipos.push(type);
	}

	private String popType() {
		return pila_tipos.pop();
	}
:};

// Terminals
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal INTEGER_CONSTANT;
terminal STRING_CONSTANT;
terminal FLOAT_CONSTANT;
terminal IDENTIFIER;
terminal OP_MAY;
terminal OP_MEN;
terminal OP_IG;
terminal OP_MAYIG;
terminal OP_MENIG;
terminal AND;
terminal OR;
terminal NOT;
terminal DISTINCT;
terminal COMA;
terminal DOS_PUNTOS;
terminal PYC;
terminal CLOSE_CURLY;
terminal OPEN_CURLY;
terminal COR_A;
terminal COR_C;
terminal IF;
terminal ELSE;
terminal FOR;
terminal INIT;
terminal WRITE;
terminal READ;
terminal FLOAT;
terminal INT;
terminal STRING;
terminal WHILE;
terminal NEGATIVECALC;
terminal SUMFIRSTPRIMES;

// Non Terminals
non terminal ss;
non terminal declaration;
non terminal listdec;
non terminal sentdec;
non terminal program;
non terminal listid;
non terminal iteration;
non terminal selection;
non terminal sentence;
non terminal assignment;
non terminal expression;
non terminal term;
non terminal factor;
non terminal input;
non terminal output;
non terminal condition;
non terminal comparison;
non terminal comparator;
non terminal function;
non terminal listconst;
non terminal listexpr;

// Attributes for non terminals
non terminal Integer expr_val;
non terminal String comp_op;
non terminal Integer cond_val;

// Start Symbol Definition
start with ss;

// Grammar Rules
ss
    ::= declaration program
        {: System.out.println("Inicio de programa principal con bloque de declaracion de variables: "); :}
    |   declaration
        {: System.out.println("Inicio del programa principal con declaracion y sin programa: "); :}
    |   program
        {: System.out.println("Inicio del programa principal sin declaracion: "); :}
    |
        {: System.out.println("Sin nada: "); :}
    ;

declaration
    ::= INIT OPEN_CURLY listdec CLOSE_CURLY
        {: System.out.println("Declaracion de variables: "); :}
    ;

listdec
    ::= listdec sentdec
        {: System.out.println("Lista de sentencia de declaracion de variables: "); :}
    |   sentdec
        {:
            System.out.println("Sentencia unica de declaracion de variables: ");
            //symbolList.add(currentSymbol);
        :}
    ;

sentdec
    ::= listid DOS_PUNTOS INT
        {: 
            currentType = "Int";
            while (!pila_ids.empty()) {
                String id = pila_ids.pop();
                addSymbol(id, currentType, null, 0);
            }
            System.out.println("Lista de variables enteras: "); 
        :}
    |   listid DOS_PUNTOS FLOAT
        {: 
            currentType = "Float";
            while (!pila_ids.empty()) {
                String id = pila_ids.pop();
                addSymbol(id, currentType, null, 0);
            }
            System.out.println("Lista de variables flotantes: "); 
        :}
    |   listid DOS_PUNTOS STRING
        {: 
            currentType = "String";
            while (!pila_ids.empty()) {
                String id = pila_ids.pop();
                addSymbol(id, currentType, null, 0);
            }
            System.out.println("Lista de variables strings: "); 
        :}
    ;

listid
    ::= listid COMA IDENTIFIER:id
        {:
            validateIdentifierLength(id.toString());
            pila_ids.push(id.toString());
            System.out.println("Lista de IDs: "); 
        :}
    |   IDENTIFIER:id
        {:
            validateIdentifierLength(id.toString());
            pila_ids.push(id.toString());
        :}
    ;

program
    ::= sentence
        {: System.out.println("Sentencia única en el programa: "); :}
    |   sentence PYC
        {: System.out.println("Sentencia con punto y coma en el programa: "); :}
    |   program sentence
        {: System.out.println("Programa con múltiples sentencias: "); :}
    |   program sentence PYC
        {: System.out.println("Programa con múltiples sentencias: "); :}
    ;

sentence
    ::= assignment
        {: System.out.println("Asignación encontrada"); :}
    |   iteration
        {: System.out.println("Iteración encontrada"); :}
    |   selection
        {: System.out.println("Selección encontrada"); :}
    |   input
        {: System.out.println("Entrada: "); :}
    |   output
        {: System.out.println("Salida: "); :}
    ;

// Entrada y salida
input
    ::= READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
        {: System.out.println("Sentencia de Entrada: "); :}
    ;

output
    ::= WRITE OPEN_BRACKET STRING_CONSTANT CLOSE_BRACKET
        {: System.out.println("Sentencia de entrada de una constante string: "); :}
    |   WRITE OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
        {: System.out.println("Sentencia de entrada de un id: "); :}
    ;

assignment
    ::= IDENTIFIER:id ASSIG expression:e
        {:
            String idType = getType(id.toString());
            if (idType == null) {
                throw new Exception("Variable no declarada: " + id);
            }
            String exprType = getExpressionType(e);
            if (!areTypesCompatible(idType, exprType)) {
                throw new Exception("No se puede asignar " + exprType + " a variable de tipo " + idType);
            }
            newTerceto(":=", id.toString(), referenceTerceto(e));
            System.out.println("Asignación: generando terceto"); 
        :}
    ;

selection
    ::= IF OPEN_BRACKET condition:c CLOSE_BRACKET
        {:
            int terceto_cond = newTerceto("BF", referenceTerceto(c), "_");
            apilar(terceto_cond);
        :}
        OPEN_CURLY program CLOSE_CURLY
        {:
            int terceto_fin = terceto_count;
            int terceto_cond = desapilar();
            tercetos.get(terceto_cond-1).setOperando2(referenceTerceto(terceto_fin));
        :}
    |   IF OPEN_BRACKET condition:c CLOSE_BRACKET
        {:
            int terceto_cond = newTerceto("BF", referenceTerceto(c), "_");
            apilar(terceto_cond);
        :}
        OPEN_CURLY program CLOSE_CURLY
        {:
            int terceto_salto = newTerceto("BI", "_", "_");
            int terceto_else = terceto_count;
            int terceto_cond = desapilar();
            tercetos.get(terceto_cond-1).setOperando2(referenceTerceto(terceto_else));
            apilar(terceto_salto);
        :}
        ELSE OPEN_CURLY program CLOSE_CURLY
        {:
            int terceto_fin = terceto_count;
            int terceto_salto = desapilar();
            tercetos.get(terceto_salto-1).setOperando1(referenceTerceto(terceto_fin));
        :}
    ;

iteration
    ::= WHILE
        {:
            apilar(terceto_count);
        :}
        OPEN_BRACKET condition:c CLOSE_BRACKET
        {:
            int terceto_cond = newTerceto("BF", referenceTerceto(c), "_");
            apilar(terceto_cond);
        :}
        OPEN_CURLY program CLOSE_CURLY
        {:
            int inicio = desapilar();
            int terceto_salto = newTerceto("BI", referenceTerceto(inicio), "_");
            int terceto_fin = terceto_count;
            int terceto_cond = desapilar();
            tercetos.get(terceto_cond-1).setOperando2(referenceTerceto(terceto_fin));
        :}
    ;

condition
    ::= comparison:c
        {: 
            RESULT = c;
            System.out.println("Condición simple"); 
        :}
    |   condition:c1 AND comparison:c2
        {:
            int terceto = newTerceto("AND", referenceTerceto(c1), referenceTerceto(c2));
            RESULT = terceto;
            System.out.println("Condición AND"); 
        :}
    |   condition:c1 OR comparison:c2
        {:
            int terceto = newTerceto("OR", referenceTerceto(c1), referenceTerceto(c2));
            RESULT = terceto;
            System.out.println("Condición OR"); 
        :}
    ;

comparison
    ::= expression:e1 comparator:op expression:e2
        {:
            String type1 = getExpressionType(e1);
            String type2 = getExpressionType(e2);
            if (!areTypesCompatible(type1, type2)) {
                throw new Exception("No se pueden comparar tipos " + type1 + " y " + type2);
            }
            int terceto = newTerceto(op, referenceTerceto(e1), referenceTerceto(e2));
            RESULT = terceto;
            System.out.println("Comparación"); 
        :}
    |   NOT expression:e1 comparator:op expression:e2
        {:
            String type1 = getExpressionType(e1);
            String type2 = getExpressionType(e2);
            if (!areTypesCompatible(type1, type2)) {
                throw new Exception("No se pueden comparar tipos " + type1 + " y " + type2);
            }
            int comp = newTerceto(op, referenceTerceto(e1), referenceTerceto(e2));
            int terceto = newTerceto("NOT", referenceTerceto(comp), "_");
            RESULT = terceto;
            System.out.println("Comparación NOT"); 
        :}
    ;

comparator
    ::= OP_MAYIG
        {: System.out.println("Comparador >= "); :}
    |   OP_MENIG
        {: System.out.println("Comparador <= "); :}
    |   OP_MAY
        {: System.out.println("Comparador > "); :}
    |   OP_MEN
        {: System.out.println("Comparador < "); :}
    |   OP_IG
        {: System.out.println("Comparador == "); :}
    ;

expression
    ::= expression:e1 PLUS term:t
        {:
            String type1 = getExpressionType(e1);
            String type2 = getExpressionType(t);
            if (!areTypesCompatible(type1, type2)) {
                throw new Exception("Tipos incompatibles en la suma: " + type1 + " y " + type2);
            }
            int terceto = newTerceto("+", referenceTerceto(e1), referenceTerceto(t));
            RESULT = terceto;
            pushType(type1.equals("Float") || type2.equals("Float") ? "Float" : "Int");
            System.out.println("Expresión suma: generando terceto"); 
        :}
    |   expression:e1 SUB term:t
        {:
            String type1 = getExpressionType(e1);
            String type2 = getExpressionType(t);
            if (!areTypesCompatible(type1, type2)) {
                throw new Exception("Tipos incompatibles en la resta: " + type1 + " y " + type2);
            }
            int terceto = newTerceto("-", referenceTerceto(e1), referenceTerceto(t));
            RESULT = terceto;
            pushType(type1.equals("Float") || type2.equals("Float") ? "Float" : "Int");
            System.out.println("Expresión resta: generando terceto"); 
        :}
    |   term:t
        {:
            RESULT = t;
            pushType(getExpressionType(t));
            System.out.println("Expresión simple: pasando valor"); 
        :}
    |   function:f
        {:
            RESULT = f;
            System.out.println("Expresión es función especial"); 
        :}
    ;

function
  ::= NEGATIVECALC OPEN_BRACKET listconst:l CLOSE_BRACKET
      {:
          int terceto = newTerceto("NEGATIVECALC", referenceTerceto(l), "_");
          RESULT = terceto;
          pushType("Int");
          System.out.println("Función NEGATIVECALC"); 
      :}
  | SUMFIRSTPRIMES OPEN_BRACKET expression:e CLOSE_BRACKET
      {:
          String type = getExpressionType(e);
          if (!type.equals("Int")) {
              throw new Exception("SUMFIRSTPRIMES requiere un argumento entero");
          }
          int terceto = newTerceto("SUMFIRSTPRIMES", referenceTerceto(e), "_");
          RESULT = terceto;
          pushType("Int");
          System.out.println("Función SUMFIRSTPRIMES"); 
      :}
  ;

listconst
    ::= listconst COMA INTEGER_CONSTANT
        {: System.out.println("Componente de lista: Constante entera "); :}
    |   listconst COMA FLOAT_CONSTANT
        {: System.out.println("Componente de lista: Constante flotante "); :}
    |   FLOAT_CONSTANT
        {: System.out.println("Constante entera: "); :}
    |   INTEGER_CONSTANT
        {: System.out.println("Constante entera: "); :}
    ;

listexpr
    ::= listexpr COMA expression
        {: System.out.println("Componente de lista: expresion "); :}
    |   expression
        {: System.out.println("Expresion: "); :}
    ;

term
    ::= term:t MULT factor:f
        {:
            String type1 = getExpressionType(t);
            String type2 = getExpressionType(f);
            if (!areTypesCompatible(type1, type2)) {
                throw new Exception("Tipos incompatibles en la multiplicación: " + type1 + " y " + type2);
            }
            int terceto = newTerceto("*", referenceTerceto(t), referenceTerceto(f));
            RESULT = terceto;
            pushType(type1.equals("Float") || type2.equals("Float") ? "Float" : "Int");
            System.out.println("Término multiplicación: generando terceto"); 
        :}
    |   term:t DIV factor:f
        {:
            String type1 = getExpressionType(t);
            String type2 = getExpressionType(f);
            if (!areTypesCompatible(type1, type2)) {
                throw new Exception("Tipos incompatibles en la división: " + type1 + " y " + type2);
            }
            int terceto = newTerceto("/", referenceTerceto(t), referenceTerceto(f));
            RESULT = terceto;
            pushType("Float"); // División siempre resulta en Float
            System.out.println("Término división: generando terceto"); 
        :}
    |   factor:f
        {:
            RESULT = f;
            pushType(getExpressionType(f));
            System.out.println("Término simple: pasando valor"); 
        :}
    ;

factor
    ::= IDENTIFIER:id
        {:
            String type = getType(id.toString());
            if (type == null) {
                throw new Exception("Variable no declarada: " + id);
            }
            int terceto = newTerceto("id", id.toString(), "_");
            RESULT = terceto;
            System.out.println("Factor ID: generando terceto"); 
        :}
    |   INTEGER_CONSTANT:num
        {:
            // Validar rango del entero
            try {
                int value = Integer.parseInt(num.toString());
                if (value < -32768 || value > 32767) {
                    throw new Exception("Constante entera fuera de rango: " + value);
                }
            } catch (NumberFormatException e) {
                throw new Exception("Constante entera inválida: " + num);
            }
            int terceto = newTerceto("cte", num.toString(), "_");
            addSymbol("_" + num.toString(), "Int", num.toString(), 0);
            RESULT = terceto;
            System.out.println("Factor constante entera: generando terceto"); 
        :}
    |   FLOAT_CONSTANT:num
        {:
            // Validar rango del float
            try {
                double value = Double.parseDouble(num.toString());
                if (value < -3.4E+38 || value > 3.4E+38) {
                    throw new Exception("Constante flotante fuera de rango: " + value);
                }
            } catch (NumberFormatException e) {
                throw new Exception("Constante flotante inválida: " + num);
            }
            int terceto = newTerceto("cte", num.toString(), "_");
            addSymbol("_" + num.toString(), "Float", num.toString(), 0);
            RESULT = terceto;
            System.out.println("Factor constante flotante: generando terceto"); 
        :}
    |   STRING_CONSTANT:str
        {:
            String value = str.toString();
            if (value.length() > 50) {
                throw new Exception("Constante string demasiado larga: " + value);
            }
            int terceto = newTerceto("cte", value, "_");
            addSymbol("_" + value, "String", value, value.length());
            RESULT = terceto;
            System.out.println("Factor constante string: generando terceto"); 
        :}
    |   OPEN_BRACKET expression:e CLOSE_BRACKET
        {:
            RESULT = e;
            System.out.println("Factor expresión entre paréntesis: pasando valor"); 
        :}
    ;