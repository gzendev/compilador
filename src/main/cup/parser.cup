package lyc.compiler;

import java_cup.runtime.*;
import lyc.compiler.tercetos.GeneradorTercetos;
import lyc.compiler.model.SymbolTable;
import lyc.compiler.model.SemanticException;

class Parser;

parser code
{:
	public GeneradorTercetos generadorTercetos = new GeneradorTercetos();
	public SymbolTable symbolTable = new SymbolTable();
	//SymbolTableStruct currentSymbol;
	//public List<SymbolTableStruct> symbolList = new ArrayList();
:};

// Terminals
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal INTEGER_CONSTANT;
terminal STRING_CONSTANT;
terminal FLOAT_CONSTANT;
terminal IDENTIFIER;
terminal OP_MAY;
terminal OP_MEN;
terminal OP_IG;
terminal OP_MAYIG;
terminal OP_MENIG;
terminal AND;
terminal OR;
terminal NOT;
terminal DISTINCT;
terminal COMA;
terminal DOS_PUNTOS;
terminal PYC;
terminal CLOSE_CURLY;
terminal OPEN_CURLY;
terminal COR_A;
terminal COR_C;
terminal IF;
terminal ELSE;
terminal FOR;
terminal INIT;
terminal WRITE;
terminal READ;
terminal FLOAT;
terminal INT;
terminal STRING;
terminal WHILE;
terminal NEGATIVECALC;
terminal SUMFIRSTPRIMES;

// Non Terminals
non terminal ss;
non terminal declaration;
non terminal listdec;
non terminal sentdec;
non terminal program;
non terminal listid;
non terminal iteration;
non terminal selection;
non terminal sentence;
non terminal assignment;
non terminal expression;
non terminal term;
non terminal factor;
non terminal input;
non terminal output;
non terminal condition;
non terminal comparison;
non terminal comparator;
non terminal function;
non terminal listconst;
non terminal listexpr;

// Start Symbol Definition
start with ss;

// Grammar Rules
ss
    ::= declaration program
        {: System.out.println("Inicio de programa principal con bloque de declaracion de variables: "); :}
    |   declaration
        {: System.out.println("Inicio del programa principal con declaracion y sin programa: "); :}
    |   program
        {: System.out.println("Inicio del programa principal sin declaracion: "); :}
    |
        {: System.out.println("Sin nada: "); :}
    ;

declaration
    ::= INIT OPEN_CURLY listdec CLOSE_CURLY
        {: System.out.println("Declaracion de variables: "); :}
    ;

listdec
    ::= listdec sentdec
        {: System.out.println("Lista de sentencia de declaracion de variables: "); :}
    |   sentdec
        {:
            System.out.println("Sentencia unica de declaracion de variables: ");
            //symbolList.add(currentSymbol);
        :}
    ;

sentdec
    ::= listid:ids DOS_PUNTOS INT
        {:
            try {
                if (ids instanceof String) {
                    symbolTable.addVariable((String)ids, "int");
                }
                System.out.println("Lista de variables enteras: ");
            } catch (SemanticException e) {
                throw new RuntimeException(e);
            }
        :}
    |   listid:ids DOS_PUNTOS FLOAT
        {:
            try {
                if (ids instanceof String) {
                    symbolTable.addVariable((String)ids, "float");
                }
                System.out.println("Lista de variables flotantes: ");
            } catch (SemanticException e) {
                throw new RuntimeException(e);
            }
        :}
    |   listid:ids DOS_PUNTOS STRING
        {:
            try {
                if (ids instanceof String) {
                    symbolTable.addVariable((String)ids, "string");
                }
                System.out.println("Lista de variables strings: ");
            } catch (SemanticException e) {
                throw new RuntimeException(e);
            }
        :}
    ;

listid
    ::= listid:list COMA IDENTIFIER:id
        {: 
            System.out.println("Lista de IDs: ");
            RESULT = list;
        :}
    |   IDENTIFIER:id
        {: 
            RESULT = id;
        :}
    ;

program
    ::= sentence
        {: System.out.println("Sentencia única en el programa: "); :}
    |   sentence PYC
        {: System.out.println("Sentencia con punto y coma en el programa: "); :}
    |   program sentence
        {: System.out.println("Programa con múltiples sentencias: "); :}
    |   program sentence PYC
        {: System.out.println("Programa con múltiples sentencias: "); :}
    ;

sentence
    ::= assignment
        {: System.out.println("Asignación encontrada"); :}
    |   iteration
        {: System.out.println("Iteración encontrada"); :}
    |   selection
        {: System.out.println("Selección encontrada"); :}
    |   input
        {: System.out.println("Entrada: "); :}
    |   output
        {: System.out.println("Salida: "); :}
    ;

// Entrada y salida
input
    ::= READ OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
        {: System.out.println("Sentencia de Entrada: "); :}
    ;

output
    ::= WRITE OPEN_BRACKET STRING_CONSTANT CLOSE_BRACKET
        {: System.out.println("Sentencia de entrada de una constante string: "); :}
    |   WRITE OPEN_BRACKET IDENTIFIER CLOSE_BRACKET
        {: System.out.println("Sentencia de entrada de un id: "); :}
    ;

assignment
    ::= IDENTIFIER:id ASSIG expression:expr
        {:
            try {
                String type = symbolTable.getType(id.toString());
                symbolTable.assignValue(id.toString(), expr);
                generadorTercetos.apilar(id.toString());
                generadorTercetos.crearTercetoAsignacion();
                System.out.println("Asignación: " + id + " = " + expr);
            } catch (SemanticException e) {
                throw new RuntimeException(e);
            }
        :}
    ;

selection
    ::= IF OPEN_BRACKET condition:cond CLOSE_BRACKET OPEN_CURLY program:prog CLOSE_CURLY
        {:
            // El terceto de comparación ya fue creado por la regla condition
            String etiquetaFalso = "[" + generadorTercetos.getIndiceActual() + "]";
            generadorTercetos.crearTercetoBranch("BF", etiquetaFalso); // Branch if false
        :}
    |   IF OPEN_BRACKET condition:cond CLOSE_BRACKET OPEN_CURLY program:prog1 CLOSE_CURLY ELSE OPEN_CURLY program:prog2 CLOSE_CURLY
        {:
            // El terceto de comparación ya fue creado por la regla condition
            int indiceActual = generadorTercetos.getIndiceActual();
            String etiquetaElse = "[" + indiceActual + "]";
            generadorTercetos.crearTercetoBranch("BF", etiquetaElse); // Branch if false al else
            // Después del bloque if, saltar al final
            String etiquetaFin = "[" + (indiceActual + 1) + "]";
            generadorTercetos.crearTercetoBranch("BI", etiquetaFin); // Branch incondicional al fin
        :}
    ;

iteration
    ::= WHILE OPEN_BRACKET condition:cond CLOSE_BRACKET OPEN_CURLY program:prog CLOSE_CURLY
        {:
            String etiquetaInicio = "[" + (generadorTercetos.getIndiceActual() - 1) + "]";
            String etiquetaFin = "[" + generadorTercetos.getIndiceActual() + "]";
            generadorTercetos.crearTercetoBranch("BF", etiquetaFin); // Branch if false al fin
            generadorTercetos.crearTercetoBranch("BI", etiquetaInicio); // Branch incondicional al inicio
        :}
    |   FOR OPEN_BRACKET assignment:init PYC condition:cond PYC expression:step CLOSE_BRACKET OPEN_CURLY program:prog CLOSE_CURLY
        {:
            String etiquetaInicio = "[" + (generadorTercetos.getIndiceActual() - 1) + "]";
            String etiquetaFin = "[" + generadorTercetos.getIndiceActual() + "]";
            generadorTercetos.crearTercetoBranch("BF", etiquetaFin);
            // Generar el paso del for
            generadorTercetos.crearTercetoBranch("BI", etiquetaInicio);
        :}
    ;

condition
    ::= comparison:comp
        {: RESULT = comp; :}
    |   condition:c1 AND comparison:c2
        {:
            generadorTercetos.crearTercetoOperacion("AND");
        :}
    |   condition:c1 OR comparison:c2
        {:
            generadorTercetos.crearTercetoOperacion("OR");
        :}
    ;

comparison
    ::= expression:e1 comparator:comp expression:e2
        {:
            generadorTercetos.crearTercetoComparacion(comp.toString());
        :}
    |   NOT expression:e1 comparator:comp expression:e2
        {:
            generadorTercetos.crearTercetoComparacion("NOT" + comp.toString());
        :}
    ;

comparator
    ::= OP_MAYIG    {: RESULT = ">="; :}
    |   OP_MENIG    {: RESULT = "<="; :}
    |   OP_MAY      {: RESULT = ">"; :}
    |   OP_MEN      {: RESULT = "<"; :}
    |   OP_IG       {: RESULT = "=="; :}
    ;

expression
    ::= expression:e1 PLUS term:t
        {:
            generadorTercetos.crearTercetoOperacion("+");
            System.out.println("Expresión suma: " + e1 + " + " + t);
            if (e1 instanceof Number && t instanceof Number) {
                if (e1 instanceof Double || t instanceof Double) {
                    RESULT = ((Number)e1).doubleValue() + ((Number)t).doubleValue();
                } else {
                    RESULT = ((Number)e1).intValue() + ((Number)t).intValue();
                }
            } else {
                RESULT = e1;
            }
        :}
    |   expression:e1 SUB term:t
        {:
            generadorTercetos.crearTercetoOperacion("-");
            System.out.println("Expresión resta: " + e1 + " - " + t);
            if (e1 instanceof Number && t instanceof Number) {
                if (e1 instanceof Double || t instanceof Double) {
                    RESULT = ((Number)e1).doubleValue() - ((Number)t).doubleValue();
                } else {
                    RESULT = ((Number)e1).intValue() - ((Number)t).intValue();
                }
            } else {
                RESULT = e1;
            }
        :}
    |   term:t
        {: 
            RESULT = t;
        :}
    |   function:f
        {: 
            System.out.println("Expresion es Funcion especial: ");
            RESULT = f;
        :}
    ;

function
    ::= NEGATIVECALC OPEN_BRACKET listconst CLOSE_BRACKET
        {: 
            System.out.println("Regla: funcion -> negativeCalculation");
            RESULT = 0; // Temporal hasta implementar la función
        :}
    |   SUMFIRSTPRIMES OPEN_BRACKET expression:e CLOSE_BRACKET
        {: 
            System.out.println("Regla: funcion -> sumFirstPrimes");
            if (e instanceof Number) {
                int n = ((Number)e).intValue();
                // Aquí implementar la lógica de sumFirstPrimes
                RESULT = n; // Temporal hasta implementar la función
            } else {
                RESULT = 0;
            }
        :}
    ;

listconst
    ::= listconst COMA INTEGER_CONSTANT
        {: System.out.println("Componente de lista: Constante entera "); :}
    |   listconst COMA FLOAT_CONSTANT
        {: System.out.println("Componente de lista: Constante flotante "); :}
    |   FLOAT_CONSTANT
        {: System.out.println("Constante entera: "); :}
    |   INTEGER_CONSTANT
        {: System.out.println("Constante entera: "); :}
    ;

listexpr
    ::= listexpr:list COMA expression:expr
        {: 
            System.out.println("Componente de lista: expresion ");
            RESULT = list;
        :}
    |   expression:expr
        {: 
            System.out.println("Expresion: ");
            RESULT = expr;
        :}
    ;

term
    ::= term:t MULT factor:f
        {:
            generadorTercetos.crearTercetoOperacion("*");
            System.out.println("Término multiplicación: " + t + " * " + f);
            if (t instanceof Number && f instanceof Number) {
                if (t instanceof Double || f instanceof Double) {
                    RESULT = ((Number)t).doubleValue() * ((Number)f).doubleValue();
                } else {
                    RESULT = ((Number)t).intValue() * ((Number)f).intValue();
                }
            } else {
                RESULT = t;
            }
        :}
    |   term:t DIV factor:f
        {:
            generadorTercetos.crearTercetoOperacion("/");
            System.out.println("Término división: " + t + " / " + f);
            if (t instanceof Number && f instanceof Number) {
                if (t instanceof Double || f instanceof Double) {
                    RESULT = ((Number)t).doubleValue() / ((Number)f).doubleValue();
                } else {
                    RESULT = ((Number)t).intValue() / ((Number)f).intValue();
                }
            } else {
                RESULT = t;
            }
        :}
    |   factor:f
        {: 
            RESULT = f;
        :}
    ;

factor
    ::= IDENTIFIER:id
        {:
            try {
                String type = symbolTable.getType(id.toString());
                generadorTercetos.apilar(id.toString());
                // Return the variable name as is, don't try to convert it
                RESULT = id.toString();
            } catch (SemanticException e) {
                throw new RuntimeException(e);
            }
        :}
    |   INTEGER_CONSTANT:num
        {:
            generadorTercetos.apilar(num.toString());
            RESULT = Integer.parseInt(num.toString());
        :}
    |   FLOAT_CONSTANT:num
        {:
            generadorTercetos.apilar(num.toString());
            RESULT = Double.parseDouble(num.toString());
        :}
    |   STRING_CONSTANT:str
        {:
            generadorTercetos.apilar(str.toString());
            RESULT = str.toString();
        :}
    |   OPEN_BRACKET expression:e CLOSE_BRACKET
        {: 
            RESULT = e;
        :}
    ;